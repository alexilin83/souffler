import './App.svelte.css.proxy.js';
/* src\js\App.svelte generated by Svelte v3.35.0 */
import {
	SvelteComponent,
	action_destroyer,
	append,
	attr,
	binding_callbacks,
	destroy_each,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	space,
	text as text_1,
	to_number,
	toggle_class
} from "../../_snowpack/pkg/svelte/internal.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	return child_ctx;
}

// (22:4) {:else}
function create_else_block(ctx) {
	let div1;
	let canvas_1;
	let canvas_action;
	let t0;
	let div0;
	let input;
	let t1;
	let div2;
	let mounted;
	let dispose;
	let each_value = /*wordsArr*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			canvas_1 = element("canvas");
			t0 = space();
			div0 = element("div");
			input = element("input");
			t1 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(input, "type", "range");
			attr(input, "min", "0");
			attr(input, "max", "200");
			attr(input, "step", "100");
			attr(div0, "class", "absolute top-0 right-0 p-2");
			attr(div1, "class", "relative w-full h-1/6 flex-initial bg-gray-500 text-white");
			attr(div2, "class", "text w-full h-5/6 flex-initial flex-wrap overflow-y-auto p-4 xl:p-8 bg-gray-100 text-5xl xl:text-8xl svelte-17g2cr5");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, canvas_1);
			append(div1, t0);
			append(div1, div0);
			append(div0, input);
			set_input_value(input, /*sensivity*/ ctx[3]);
			insert(target, t1, anchor);
			insert(target, div2, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			/*div2_binding*/ ctx[7](div2);

			if (!mounted) {
				dispose = [
					action_destroyer(canvas_action = /*canvas*/ ctx[5].call(null, canvas_1)),
					listen(input, "change", /*input_change_input_handler*/ ctx[6]),
					listen(input, "input", /*input_change_input_handler*/ ctx[6])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*sensivity*/ 8) {
				set_input_value(input, /*sensivity*/ ctx[3]);
			}

			if (dirty & /*wordsArr*/ 1) {
				each_value = /*wordsArr*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (detaching) detach(t1);
			if (detaching) detach(div2);
			destroy_each(each_blocks, detaching);
			/*div2_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (20:4) {#if !audioCtx}
function create_if_block(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = "Начать";
			attr(button, "class", "absolute left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-500 px-4 py-2 text-white rounded-lg");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*start*/ ctx[4]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (30:12) {#each wordsArr as item}
function create_each_block(ctx) {
	let span;
	let t_value = /*item*/ ctx[27].word + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text_1(t_value);
			attr(span, "class", "relative inline-block mr-5 mb-5 p-5 leading-none svelte-17g2cr5");
			toggle_class(span, "checked", /*item*/ ctx[27].checked);
			toggle_class(span, "bg-red-500", /*item*/ ctx[27].marked);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*wordsArr*/ 1 && t_value !== (t_value = /*item*/ ctx[27].word + "")) set_data(t, t_value);

			if (dirty & /*wordsArr*/ 1) {
				toggle_class(span, "checked", /*item*/ ctx[27].checked);
			}

			if (dirty & /*wordsArr*/ 1) {
				toggle_class(span, "bg-red-500", /*item*/ ctx[27].marked);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment(ctx) {
	let div;

	function select_block_type(ctx, dirty) {
		if (!/*audioCtx*/ ctx[1]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "container mx-auto h-screen flex flex-wrap");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

const data = "Повседневная практика показывает, что рамки и место обучения кадров обеспечивает широкому кругу (специалистов) участие в формировании позиций, занимаемых участниками в отношении поставленных задач. Не следует, однако забывать, что укрепление и развитие структуры обеспечивает широкому кругу (специалистов) участие в формировании дальнейших направлений развития. Товарищи! консультация с широким активом играет важную роль в формировании модели развития. Повседневная практика показывает, что консультация с широким активом требуют от нас анализа новых предложений. Разнообразный и богатый опыт начало повседневной работы по формированию позиции в значительной степени обуславливает создание дальнейших направлений развития. Не следует, однако забывать, что укрепление и развитие структуры играет важную роль в формировании систем массового участия.";

function instance($$self, $$props, $$invalidate) {
	const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
	const SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList;
	const SpeechRecognitionEvent = window.SpeechRecognitionEvent || window.webkitSpeechRecognitionEvent;
	const dataArr = data.split(" ");

	let wordsArr = dataArr.map(item => {
		return {
			word: item.replace(/[^а-я\d\s]+/gi, ""),
			checked: false,
			marked: false
		};
	});

	let audioCtx;
	let analyser;
	let source;
	let text;
	let canvasCtx;
	let WIDTH;
	let HEIGHT;
	let drawVisual;
	let bufferLengthAlt;
	let dataArrayAlt;
	let volume;
	let sensivity = 100;
	let grammar;
	let recognition;
	let speechRecognitionList;

	function start() {
		$$invalidate(1, audioCtx = new (window.AudioContext || window.webkitAudioContext)());
		analyser = audioCtx.createAnalyser();

		navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then(function (stream) {
			source = audioCtx.createMediaStreamSource(stream);
			source.connect(analyser);
			visualize();
			recognition.start();
		}).catch(function (err) {
			console.error(err);
		});

		grammar = "#JSGF V1.0; grammar words; public <word> = " + dataArr.join(" | ") + " ;";
		recognition = new SpeechRecognition();
		speechRecognitionList = new SpeechGrammarList();
		speechRecognitionList.addFromString(grammar, 1);
		recognition.grammars = speechRecognitionList;
		recognition.lang = "ru-RU";
		recognition.interiumResults = false;
		recognition.maxAlternatives = 1;

		recognition.addEventListener("start", function () {
			console.log("start");
		});

		recognition.addEventListener("end", function () {
			console.log("end");
			recognition.start();
		});

		recognition.addEventListener("audiostart", function () {
			console.log("audio start");
		});

		recognition.addEventListener("audioend", function () {
			console.log("audio end");
		});

		recognition.addEventListener("soundstart", function () {
			console.log("sound start");
		});

		recognition.addEventListener("soundend", function () {
			console.log("sound end");
		});

		recognition.addEventListener("speechstart", function () {
			console.log("speech start");
		});

		recognition.addEventListener("speechend", function () {
			console.log("speech end");
		});

		recognition.addEventListener("result", function (event) {
			console.log("result");
			const last = event.results.length - 1;
			let curWords = event.results[last][0].transcript.split(" ");
			console.log(curWords);
			console.log(event.results[0][0].confidence);
			highlightWords(curWords);
		});

		recognition.addEventListener("nomatch", function (event) {
			console.log("Can't recognise text.");
		});

		recognition.addEventListener("error", function (event) {
			console.error(`Error occurred in recognition: ${event.error}`);
		});
	}

	function highlightWords(arr) {
		$$invalidate(0, wordsArr = wordsArr.map(item => {
			if (!item.checked && arr.length) {
				if (item.word.toLowerCase() === arr[0]) {
					item = { ...item, checked: true, marked: true };
				} else {
					item = { ...item, checked: true };
				}

				arr.shift();
			}

			return item;
		}));

		console.log(wordsArr);
	}

	function canvas(node) {
		canvasCtx = node.getContext("2d");
		node.setAttribute("width", node.parentNode.clientWidth);
		node.setAttribute("height", node.parentNode.clientHeight);
		WIDTH = node.parentNode.clientWidth;
		HEIGHT = node.parentNode.clientHeight;
	}

	function visualize() {
		analyser.fftSize = 256;
		analyser.minDecibels = -90;
		analyser.maxDecibels = -10;
		analyser.smoothingTimeConstant = 0.85;
		bufferLengthAlt = analyser.frequencyBinCount;
		dataArrayAlt = new Uint8Array(bufferLengthAlt);
		canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
		draw();
	}

	function draw() {
		drawVisual = requestAnimationFrame(draw);
		analyser.getByteFrequencyData(dataArrayAlt);
		canvasCtx.fillStyle = "rgb(0, 0, 0)";
		canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
		let barWidth = WIDTH / bufferLengthAlt * 2.5;
		let barHeight;
		let x = 0;

		for (let i = 0; i < bufferLengthAlt; i++) {
			barHeight = dataArrayAlt[i];
			canvasCtx.fillStyle = `rgb(127, ${barHeight + 100}, 0)`;
			canvasCtx.fillRect(x, HEIGHT - barHeight / 2, barWidth, barHeight / 2);
			x += barWidth + 1;
		}

		volume = Math.max(...dataArrayAlt) / 256;

		if (volume > 0.4) {
			$$invalidate(2, text.scrollTop += 1 + 1 * sensivity / 100, text);
		}
	}

	function input_change_input_handler() {
		sensivity = to_number(this.value);
		$$invalidate(3, sensivity);
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			text = $$value;
			$$invalidate(2, text);
		});
	}

	return [
		wordsArr,
		audioCtx,
		text,
		sensivity,
		start,
		canvas,
		input_change_input_handler,
		div2_binding
	];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default App;